# Automated Infrastructure Deployment Lab

In this hands-on lab, you'll deploy the same infrastructure from Week 2 (Nginx Proxy Manager and Code-Server), but using automation. Instead of running a large script, you'll execute each step yourself to understand exactly what's happening.

`This lab combines all Week 3 concepts: cloud-init, bash scripting, and Infrastructure as Code` {{ note }}

---

## What We're Automating

**Manual Process (Week 2):**
- 17 separate steps
- 50+ commands to type
- 2-3 hours of work
- High potential for errors
- Hard to reproduce exactly

**Automated Process (Week 3 - This Lab):**
- Cloud-init handles OS setup automatically
- You deploy applications step-by-step
- 15-20 minutes for infrastructure
- Tested and reliable
- Perfectly reproducible

---

## Part 1: Understanding the Two-Layer Approach

We use **two layers** of automation:

**Layer 1 - Cloud-Init (OS Setup)**
- Runs once at server creation
- Updates packages
- Installs Docker
- Creates users
- Configures firewall
- Sets up directories

**Layer 2 - Docker Deployment (Applications)**
- Runs when you're ready
- Deploys containers
- Configures applications
- Sets up SSL/TLS

**Why separate?**
- OS setup is one-time and rarely changes
- Applications may be redeployed or updated frequently
- Easier to troubleshoot when separated
- Clear separation of concerns

---

## Part 2: Prepare Your Cloud-Init Configuration

### Step 1: Create Working Directory

On your local machine:

`mkdir -p ~/brotech-labs/week3` {{ execute }}

`cd ~/brotech-labs/week3` {{ execute }}

### Step 2: Get Your SSH Public Key

Check if you have an SSH key:

`ls ~/.ssh/id_ed25519.pub` {{ execute }}

If not, generate one:

`ssh-keygen -t ed25519 -C "your-email@example.com"` {{ copy }}

Display your public key:

`cat ~/.ssh/id_ed25519.pub` {{ execute }}

**Copy the entire output** - you'll paste it into cloud-init config.

### Step 3: Create Cloud-Init Configuration File

`nano cloud-init.yaml` {{ execute }}

Paste this configuration **(remember to replace YOUR_SSH_KEY_HERE with your actual key!)**:

```yaml{{ copy }}
#cloud-config

# Update and upgrade packages on first boot
package_update: true
package_upgrade: true
package_reboot_if_required: true

# Install required packages
packages:
  # Transport packages for HTTPS repositories
  - apt-transport-https
  - ca-certificates

  # Core utilities
  - curl
  - wget
  - gnupg
  - lsb-release
  - software-properties-common

  # Docker and container tools
  - docker.io
  - docker-compose-plugin
  - docker-buildx-plugin

  # System monitoring and management
  - htop
  - ncdu
  - tree
  - jq

  # Security tools
  - ufw
  - fail2ban

  # Development tools
  - git
  - vim
  - nano
  - net-tools

# Set timezone (change to yours!)
timezone: America/New_York

# Create admin user with SSH access
users:
  - name: admin
    groups: sudo, docker
    shell: /bin/bash
    sudo: 'ALL=(ALL) NOPASSWD:ALL'
    ssh_authorized_keys:
      - YOUR_SSH_KEY_HERE

# Security: disable root password login
disable_root: false
ssh_pwauth: false

# Configure Docker daemon
write_files:
  - path: /etc/docker/daemon.json
    content: |
      {
        "log-driver": "json-file",
        "log-opts": {
          "max-size": "10m",
          "max-file": "3"
        },
        "storage-driver": "overlay2"
      }
    permissions: '0644'
    owner: root:root

# Run commands after packages installed
runcmd:
  # Start and enable Docker
  - systemctl start docker
  - systemctl enable docker
  - usermod -aG docker admin || true

  # Create Docker network for container communication
  - docker network create web_network || true

  # Configure firewall
  - ufw default deny incoming
  - ufw default allow outgoing
  - ufw allow 22/tcp comment 'SSH'
  - ufw allow 80/tcp comment 'HTTP'
  - ufw allow 443/tcp comment 'HTTPS'
  - ufw allow 81/tcp comment 'NPM Admin'
  - ufw --force enable

  # Start fail2ban security service
  - systemctl enable fail2ban
  - systemctl start fail2ban

  # Create application directories
  - mkdir -p /opt/nginx-proxy-manager
  - mkdir -p /opt/code-server
  - mkdir -p /opt/scripts
  - chown -R admin:admin /opt/nginx-proxy-manager
  - chown -R admin:admin /opt/code-server
  - chown -R admin:admin /opt/scripts

  # Log completion
  - echo "Cloud-init completed at $(date)" > /var/log/cloud-init-complete.log
  - docker --version >> /var/log/cloud-init-complete.log
  - hostname -I >> /var/log/cloud-init-complete.log

final_message: |
  ============================================================================
  Server initialization complete!
  ============================================================================
  Docker is installed and running.
  Firewall is configured and active.
  Ready for application deployment.

  Next: SSH in as 'admin' and deploy your applications!
  ============================================================================
```

**What each section does:**

- **package_update/upgrade:** Gets latest security patches
- **packages:** Installs Docker, utilities, security tools
- **timezone:** Sets server timezone
- **users:** Creates admin user with your SSH key
- **disable_root/ssh_pwauth:** Enhances security
- **write_files:** Configures Docker logging limits
- **runcmd:** Runs commands after installation
  - Starts Docker
  - Creates network for containers
  - Configures firewall
  - Creates directories
  - Enables security tools

Save and exit (`Ctrl+O`, `Enter`, `Ctrl+X`).

### Step 4: Validate Your Configuration

Check your file:

`cat cloud-init.yaml` {{ execute }}

Verify:
- âœ… First line is `#cloud-config`
- âœ… Your SSH public key is inserted
- âœ… Indentation is consistent (2 spaces)
- âœ… No tabs (use spaces only)

---

## Part 3: Create Server with Cloud-Init

### Step 1: Access Hetzner Cloud Console

Go to https://console.hetzner.cloud

Select your project (or create one).

### Step 2: Create Server

Click **"Add Server"**

**Configure:**
- **Location:** Choose closest (e.g., Ashburn, VA)
- **Image:** Ubuntu 22.04
- **Type:** CX11 (sufficient for learning)
- **Networking:** Leave defaults (IPv4 enabled)
- **SSH Keys:** Skip (cloud-init will add your key)
- **Cloud config:** **Paste your entire `cloud-init.yaml` content**
- **Name:** `week3-automated`

Click **"Create & Buy Now"**

### Step 3: Note Server IP Address

Once created, note the IP address shown. We'll refer to it as `YOUR_SERVER_IP`.

Example: `65.108.123.45`

### Step 4: Wait for Server Boot

Server takes ~60 seconds to boot.

Once it shows "Running", wait an additional 2-3 minutes for cloud-init to complete.

---

## Part 4: Connect and Verify Cloud-Init

### Step 1: SSH into Server

`ssh admin@YOUR_SERVER_IP` {{ copy }}

*Replace YOUR_SERVER_IP with your actual IP*

Accept the fingerprint when prompted.

You should be logged in as `admin` user!

### Step 2: Wait for Cloud-Init to Finish

`cloud-init status --wait` {{ execute }}

This command waits for cloud-init to complete. When done, you'll see:

```
status: done
```

If it says "running", wait a few more minutes.

### Step 3: Check Cloud-Init Logs

`cat /var/log/cloud-init-complete.log` {{ execute }}

Should show completion timestamp, Docker version, and server IP.

### Step 4: Verify Docker Installation

`docker --version` {{ execute }}

Should output: `Docker version 24.x.x` or newer.

`docker compose version` {{ execute }}

Should output: `Docker Compose version v2.x.x` or newer.

### Step 5: Verify Docker is Running

`systemctl status docker --no-pager` {{ execute }}

Should show `active (running)` in green.

### Step 6: Verify Docker Network Created

`docker network ls` {{ execute }}

Should list `web_network` created by cloud-init.

### Step 7: Verify Firewall Configuration

`sudo ufw status verbose` {{ execute }}

Should show:
- Status: `active`
- Default: `deny (incoming)`, `allow (outgoing)`
- Allowed ports: `22/tcp`, `80/tcp`, `443/tcp`, `81/tcp`

### Step 8: Verify Directories Created

`ls -la /opt/` {{ execute }}

Should show:
- `nginx-proxy-manager/` (owned by admin)
- `code-server/` (owned by admin)
- `scripts/` (owned by admin)

### Step 9: Verify User Groups

`groups` {{ execute }}

Should show: `admin sudo docker`

**âœ… If all checks pass, cloud-init worked perfectly!**

Cloud-init saved you ~45 minutes of manual setup! ðŸŽ‰

---

## Part 5: Configure DNS Records

Before deploying applications, configure DNS so you can access services by domain name.

### Step 1: Choose Subdomains

For this lab, we'll use:
- NPM Admin: `npm.brotechlabs.com`
- Code-Server: `code.brotechlabs.com`

Replace `brotechlabs.com` with your actual domain.

### Step 2: Get Your Server IP

`hostname -I | awk '{print $1}'` {{ execute }}

This is the IP to use in DNS records.

### Step 3: Add DNS A Records

In your DNS provider (Cloudflare, Namecheap, etc.), add:

| Type | Name | Value (IP) | TTL |
|------|------|------------|-----|
| A | npm | YOUR_SERVER_IP | Auto |
| A | code | YOUR_SERVER_IP | Auto |

### Step 4: Wait for DNS Propagation

DNS takes 5-10 minutes. Test with:

`nslookup npm.brotechlabs.com` {{ copy }}

`nslookup code.brotechlabs.com` {{ copy }}

Both should return your server IP.

---

## Part 6: Deploy Nginx Proxy Manager (Step-by-Step)

Now we'll deploy NPM, understanding each command instead of running a script.

### Step 1: Navigate to NPM Directory

`cd /opt/nginx-proxy-manager` {{ execute }}

This directory was created by cloud-init.

### Step 2: Create Docker Compose File

`nano docker-compose.yml` {{ execute }}

Paste this configuration:

```yaml{{ copy }}
version: '3.8'

services:
  nginx-proxy-manager:
    # Use official NPM image
    image: jc21/nginx-proxy-manager:latest

    # Give container a friendly name
    container_name: nginx-proxy-manager

    # Always restart unless manually stopped
    restart: unless-stopped

    # Port mappings: HOST:CONTAINER
    ports:
      - "80:80"       # HTTP traffic
      - "443:443"     # HTTPS traffic
      - "81:81"       # Admin web interface

    # Environment variables
    environment:
      DISABLE_IPV6: 'true'

    # Persistent storage volumes
    volumes:
      - npm-data:/data
      - npm-letsencrypt:/etc/letsencrypt

    # Connect to Docker network
    networks:
      - web_network

    # Health check - Docker monitors container health
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:81"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s

# Define volumes for persistent data
volumes:
  npm-data:
    driver: local
  npm-letsencrypt:
    driver: local

# Use existing network created by cloud-init
networks:
  web_network:
    external: true
```

**What each part means:**

- **image:** Docker image to use (like an app installer)
- **container_name:** Easy-to-remember name
- **restart: unless-stopped:** Auto-restart if crashes
- **ports:** Map server ports to container ports
  - `80:80` = HTTP web traffic
  - `443:443` = HTTPS secure traffic
  - `81:81` = NPM admin dashboard
- **volumes:** Persistent storage (survives container restarts)
  - `npm-data` = NPM configuration and database
  - `npm-letsencrypt` = SSL certificates
- **networks:** Connect to `web_network` so NPM can reach other containers
- **healthcheck:** Docker checks if NPM is working every 30 seconds

Save and exit (`Ctrl+O`, `Enter`, `Ctrl+X`).

### Step 3: Download NPM Docker Image

`docker compose pull` {{ execute }}

This downloads the NPM image from Docker Hub. Takes ~1-2 minutes.

You'll see progress bars as layers download.

### Step 4: Start NPM Container

`docker compose up -d` {{ execute }}

**Flags explained:**
- `up` = Start the services defined in docker-compose.yml
- `-d` = Detached mode (runs in background)

Output will show:
```
[+] Running 3/3
 âœ” Network nginx-proxy-manager_default  Created
 âœ” Volume npm-data                      Created
 âœ” Volume npm-letsencrypt               Created
 âœ” Container nginx-proxy-manager        Started
```

### Step 5: Verify NPM is Running

`docker ps` {{ execute }}

Should show `nginx-proxy-manager` with status "Up X seconds".

### Step 6: Check NPM Logs

`docker logs nginx-proxy-manager` {{ execute }}

Should show startup messages ending with something like:
```
[2025-XX-XX XX:XX:XX] info: ... ready for HTTP/HTTPS connections
```

No errors should appear.

### Step 7: Verify NPM Health

Wait 40 seconds (healthcheck start_period), then:

`docker inspect nginx-proxy-manager | grep -A 5 Health` {{ execute }}

Should show `"Status": "healthy"`.

### Step 8: Test NPM Admin Interface

Get your server IP:

`hostname -I | awk '{print $1}'` {{ execute }}

Open browser and navigate to: `http://YOUR_SERVER_IP:81`

You should see NPM login screen!

**Default credentials:**
- Email: `admin@example.com`
- Password: `changeme`

### Step 9: Change Default Password (Important!)

After logging in:
1. Click email address (top right)
2. Click "Edit Details"
3. Change email to yours
4. Change password (use strong password)
5. Click "Save"

**NPM is now running!** âœ…

---

## Part 7: Deploy Code-Server (Step-by-Step)

Now deploy Code-Server (VS Code in browser).

### Step 1: Navigate to Code-Server Directory

`cd /opt/code-server` {{ execute }}

### Step 2: Create Docker Compose File

`nano docker-compose.yml` {{ execute }}

Paste this configuration:

```yaml{{ copy }}
version: '3.8'

services:
  code-server:
    # Official Code-Server image
    image: codercom/code-server:latest

    # Container name
    container_name: code-server

    # Auto-restart policy
    restart: unless-stopped

    # Configuration via environment variables
    environment:
      # Password for Code-Server web login
      PASSWORD: changeme123

      # Sudo password inside the container
      SUDO_PASSWORD: changeme123

      # Domain for WebSocket support
      PROXY_DOMAIN: code.brotechlabs.com

    # Persistent storage
    volumes:
      # VS Code configuration and extensions
      - code-server-config:/home/coder/.config

      # Your project files and code
      - code-server-data:/home/coder/project

    # Connect to web network (so NPM can reach it)
    networks:
      - web_network

    # Health check
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s

# Persistent volumes
volumes:
  code-server-config:
    driver: local
  code-server-data:
    driver: local

# Use existing network
networks:
  web_network:
    external: true
```

**What each part means:**

- **environment variables:**
  - `PASSWORD` = Password to access Code-Server web interface
  - `SUDO_PASSWORD` = Password for terminal sudo inside Code-Server
  - `PROXY_DOMAIN` = Your domain (improves WebSocket performance)
- **volumes:**
  - `code-server-config` = Stores VS Code settings, extensions
  - `code-server-data` = Stores your code and project files
- **networks:**
  - `web_network` = Connects Code-Server to NPM

**IMPORTANT:** Change `changeme123` to your own strong password!

Save and exit.

### Step 3: Download Code-Server Image

`docker compose pull` {{ execute }}

Downloads the Code-Server image.

### Step 4: Start Code-Server

`docker compose up -d` {{ execute }}

Starts Code-Server in background.

### Step 5: Verify Code-Server is Running

`docker ps` {{ execute }}

Should show both `nginx-proxy-manager` and `code-server` running.

### Step 6: Check Code-Server Logs

`docker logs code-server` {{ execute }}

Should show:
```
[XXXX-XX-XX XX:XX:XX.XXX] info  code-server X.X.X
[XXXX-XX-XX XX:XX:XX.XXX] info  Using config file ~/.config/code-server/config.yaml
[XXXX-XX-XX XX:XX:XX.XXX] info  HTTP server listening on http://0.0.0.0:8080
```

### Step 7: Test Code-Server (Internal)

`curl -I http://localhost:8080` {{ execute }}

Should return HTTP 302 (redirect to login page).

**Code-Server is running!** âœ…

### Step 8: Verify Both Services

`docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"` {{ execute }}

Should show:
- `nginx-proxy-manager` - Up, ports 80, 443, 81
- `code-server` - Up

### Step 9: Check Docker Network

Verify both containers are on `web_network`:

`docker network inspect web_network | grep -A 3 Containers` {{ execute }}

Should show both containers connected.

---

## Part 8: Configure NPM Proxy Host for Code-Server

Now configure NPM to route `code.brotechlabs.com` to Code-Server.

### Access NPM Admin

Open browser: `http://YOUR_SERVER_IP:81`

Log in with your updated credentials.

### Add Proxy Host

1. Click **"Hosts"** (left sidebar)
2. Click **"Proxy Hosts"**
3. Click **"Add Proxy Host"** button

### Configure Details Tab

Fill in:

**Domain Names:**
```
code.brotechlabs.com
```
(Use your actual subdomain)

**Scheme:** `http` (we're connecting to Code-Server internally, NPM handles HTTPS externally)

**Forward Hostname / IP:** `code-server` (container name - Docker DNS resolves this!)

**Forward Port:** `8080`

**Options:**
- âœ… Cache Assets
- âœ… Block Common Exploits
- âœ… **Websockets Support** (CRITICAL for VS Code!)

Click **"Save"** (don't configure SSL yet)

### Test HTTP Access

Navigate to: `http://code.brotechlabs.com`

You should see Code-Server login page!

Enter your password (from docker-compose.yml).

**You now have VS Code in your browser!** ðŸŽ‰

---

## Part 9: Enable SSL/TLS with Let's Encrypt

Let's secure Code-Server with HTTPS.

### Edit Code-Server Proxy Host

In NPM admin:
1. Go to **"Hosts" â†’ "Proxy Hosts"**
2. Find `code.brotechlabs.com`
3. Click the **three dots (...)** â†’ **"Edit"**

### Configure SSL Tab

Click the **"SSL"** tab

**SSL Certificate:** Select **"Request a New SSL Certificate"**

**Options:**
- âœ… Force SSL
- âœ… HTTP/2 Support
- âœ… HSTS Enabled

**Email Address for Let's Encrypt:** `your-email@example.com`

- âœ… I Agree to the Let's Encrypt Terms of Service

Click **"Save"**

### Watch Certificate Request

NPM will now:
1. Request certificate from Let's Encrypt
2. Complete ACME HTTP-01 challenge
3. Install certificate
4. Configure NGINX to use it

Takes 10-30 seconds.

You'll see a progress indicator.

### Verify HTTPS

Navigate to: `https://code.brotechlabs.com`

You should see:
- ðŸ”’ Secure connection (padlock icon)
- No certificate warnings
- Code-Server login page

**SSL/TLS is working!** ðŸŽ‰ðŸ”’

### Understand What Happened

Back on server, check certificates:

`sudo ls -la /var/lib/docker/volumes/nginx-proxy-manager_npm-letsencrypt/_data/live/` {{ execute }}

You should see a directory for your domain containing:
- `cert.pem` - Certificate
- `chain.pem` - Certificate chain
- `fullchain.pem` - Full chain
- `privkey.pem` - Private key

**How ACME Protocol Worked:**

1. **Request:** NPM asked Let's Encrypt for cert
2. **Challenge:** LE said "prove you own this domain"
3. **HTTP-01:** LE requested `http://code.brotechlabs.com/.well-known/acme-challenge/TOKEN`
4. **NPM Response:** NPM served the challenge file
5. **Verification:** LE confirmed and issued cert
6. **Installation:** NPM installed cert in NGINX
7. **Renewal:** NPM will auto-renew before 90-day expiration

---

## Part 10: Add NPM Admin SSL (Optional but Recommended)

Secure the NPM admin interface too.

### Add Proxy Host for NPM

In NPM, **"Hosts" â†’ "Proxy Hosts" â†’ "Add Proxy Host"**

**Details Tab:**
- **Domain Names:** `npm.brotechlabs.com`
- **Scheme:** `http`
- **Forward Hostname/IP:** `nginx-proxy-manager` (or `localhost`)
- **Forward Port:** `81`
- **Block Common Exploits:** âœ…

**SSL Tab:**
- **Request a New SSL Certificate**
- **Force SSL:** âœ…
- **HTTP/2 Support:** âœ…
- **Email:** your-email@example.com
- **I Agree:** âœ…

Click **"Save"**

### Access NPM Admin via HTTPS

Navigate to: `https://npm.brotechlabs.com`

Now both services have HTTPS! ðŸ”’ðŸ”’

---

## Part 11: Verification and Testing

Let's verify everything works correctly.

### Check All Running Containers

`docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"` {{ execute }}

Both containers should show "Up".

### Check Docker Networks

`docker network inspect web_network --format '{{range .Containers}}{{.Name}} {{end}}'` {{ execute }}

Should list both containers.

### Check Resource Usage

`docker stats --no-stream` {{ execute }}

Shows CPU and memory usage for each container.

### Verify Firewall Rules

`sudo ufw status numbered` {{ execute }}

Should show all required ports allowed.

### Test Services in Browser

**NPM Admin (HTTPS):**
```
https://npm.brotechlabs.com
```
- Should load NPM dashboard
- Should show valid SSL certificate

**Code-Server (HTTPS):**
```
https://code.brotechlabs.com
```
- Should load VS Code interface
- Should show valid SSL certificate
- Should be fully functional

### Test Code-Server Functionality

In Code-Server:
1. Click "Open Folder" â†’ `/home/coder/project`
2. Create new file: `test.txt`
3. Write content: `Hello from automated deployment!`
4. Save (`Ctrl+S`)

Verify file persists on server:

`sudo ls -la /var/lib/docker/volumes/code-server_code-server-data/_data/` {{ execute }}

Should show `test.txt`.

**Everything is working!** ðŸŽ‰

---

## Part 12: Understanding What We Built

Let's review what automation accomplished.

### Cloud-Init Automated (5 minutes):

âœ… Updated all system packages
âœ… Installed Docker and Docker Compose
âœ… Installed 20+ utility packages
âœ… Created admin user with SSH key
âœ… Configured firewall (UFW) with all rules
âœ… Created Docker network
âœ… Set up directory structure
âœ… Configured Docker daemon logging
âœ… Enabled and started fail2ban
âœ… Logged completion details

**Manual time equivalent:** ~45 minutes

### We Did Manually (~20 minutes):

- Created docker-compose.yml for NPM
- Deployed NPM container
- Created docker-compose.yml for Code-Server
- Deployed Code-Server container
- Configured DNS records
- Created NPM proxy hosts
- Requested SSL certificates

**Could be automated further:** Yes! We could add docker-compose creation to cloud-init or create a deployment script.

### Total Time

- **Week 2 Manual:** ~140 minutes (2.3 hours)
- **Week 3 Automated:** ~30 minutes active + 5 minutes waiting
- **Time Saved:** 105 minutes (75% reduction!)

**For 5 servers:**
- **Manual:** ~700 minutes (11.7 hours)
- **Automated:** ~70 minutes (1.2 hours)
- **Time Saved:** 630 minutes (10.5 hours, 90% reduction!)

---

## Part 13: Advanced - Full Automation Script

Want to automate the docker-compose deployment too? Create a deployment script.

### Create Deployment Script

`nano /opt/scripts/deploy-apps.sh` {{ execute }}

```bash{{ copy }}
#!/bin/bash
#######################################################
# Application Deployment Script
# Deploys NPM and Code-Server automatically
#######################################################

set -e  # Exit on any error
set -x  # Print commands before executing

echo "========================================="
echo "Deploying Nginx Proxy Manager"
echo "========================================="

cd /opt/nginx-proxy-manager

# Check if docker-compose.yml exists
if [ ! -f docker-compose.yml ]; then
    echo "ERROR: docker-compose.yml not found!"
    echo "Create it first in /opt/nginx-proxy-manager"
    exit 1
fi

# Deploy NPM
docker compose pull
docker compose up -d

# Wait for NPM to be healthy
echo "Waiting for NPM to be healthy..."
sleep 10
docker ps | grep nginx-proxy-manager

echo ""
echo "========================================="
echo "Deploying Code-Server"
echo "========================================="

cd /opt/code-server

# Check if docker-compose.yml exists
if [ ! -f docker-compose.yml ]; then
    echo "ERROR: docker-compose.yml not found!"
    echo "Create it first in /opt/code-server"
    exit 1
fi

# Deploy Code-Server
docker compose pull
docker compose up -d

# Wait for Code-Server to be healthy
echo "Waiting for Code-Server to be healthy..."
sleep 10
docker ps | grep code-server

echo ""
echo "========================================="
echo "Deployment Complete!"
echo "========================================="
echo ""
docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
echo ""
echo "NPM Admin: http://$(hostname -I | awk '{print $1}'):81"
echo "Code-Server: Accessible via NPM proxy"
echo ""
echo "Next steps:"
echo "1. Configure DNS records"
echo "2. Set up NPM proxy hosts"
echo "3. Request SSL certificates"
echo ""
```

Make it executable:

`chmod +x /opt/scripts/deploy-apps.sh` {{ execute }}

### Test the Script

If you want to test redeployment:

`/opt/scripts/deploy-apps.sh` {{ execute }}

The script will redeploy both applications.

### Add to Cloud-Init for Full Automation

You could add docker-compose file creation and this script to cloud-init's `runcmd` for completely hands-off deployment!

---

## Part 14: Troubleshooting Guide

### Cloud-Init Didn't Complete

**Symptoms:**
- Can't SSH in as admin
- `cloud-init status` shows "running" for >10 min

**Diagnosis:**

`ssh root@YOUR_SERVER_IP` {{ copy }}

(Hetzner allows root login initially)

`cloud-init status` {{ execute }}

`tail -50 /var/log/cloud-init-output.log` {{ execute }}

**Common Causes:**
1. YAML syntax error
2. Invalid SSH key format
3. Network issue downloading packages
4. Package installation failed

**Solution:**
- Check logs for specific error
- Fix cloud-init.yaml
- Recreate server

### Docker Not Installed

**Symptoms:**
- `docker: command not found`

**Diagnosis:**

`which docker` {{ execute }}

`systemctl status docker` {{ execute }}

`cat /var/log/cloud-init-output.log | grep -i docker` {{ execute }}

**Solution:**

If Docker wasn't installed, cloud-init failed. Check logs:

`grep -i error /var/log/cloud-init-output.log` {{ execute }}

### Container Won't Start

**Symptoms:**
- `docker ps` doesn't show container
- Container keeps restarting

**Diagnosis:**

`docker ps -a` {{ execute }}

`docker logs nginx-proxy-manager` {{ execute }}

**Common Causes:**
1. Port already in use
2. docker-compose.yml syntax error
3. Network doesn't exist
4. Volume permission issues

**Solutions:**

Check if port is used:

`sudo lsof -i :80` {{ execute }}

`sudo lsof -i :443` {{ execute }}

Recreate container:

`cd /opt/nginx-proxy-manager` {{ execute }}

`docker compose down` {{ execute }}

`docker compose up -d` {{ execute }}

### SSL Certificate Request Failed

**Symptoms:**
- NPM shows error requesting certificate
- "Challenge failed" message

**Diagnosis:**

`docker logs nginx-proxy-manager | tail -50` {{ execute }}

**Common Causes:**
1. DNS not pointing to server
2. Port 80/443 blocked
3. Domain validation failed
4. Rate limit reached (5 requests/week per domain)

**Solutions:**

Verify DNS resolves:

`nslookup code.brotechlabs.com` {{ execute }}

Verify firewall:

`sudo ufw status | grep -E "80|443"` {{ execute }}

Test NPM can reach internet:

`docker exec nginx-proxy-manager ping -c 3 1.1.1.1` {{ execute }}

### Can't Access Services Externally

**Symptoms:**
- Works on localhost
- Doesn't work from internet

**Diagnosis:**

Test locally:

`curl -I http://localhost:81` {{ execute }}

`curl -I http://localhost:8080` {{ execute }}

Test externally:
- Try accessing from browser

**Solutions:**

Check firewall:

`sudo ufw status verbose` {{ execute }}

Check cloud provider security groups (Hetzner firewall).

Check Docker port mappings:

`docker port nginx-proxy-manager` {{ execute }}

### WebSocket Connection Failed (Code-Server)

**Symptoms:**
- Code-Server loads but is unresponsive
- "Reconnecting..." message
- Features don't work

**Diagnosis:**

Check NPM proxy host configuration.

**Solution:**

Edit Code-Server proxy host in NPM:
1. Ensure **"Websockets Support"** is âœ… ENABLED
2. Save
3. Test again

---

## Part 15: Cleanup

When finished, clean up to avoid charges.

### Stop Containers

`cd /opt/nginx-proxy-manager && docker compose down` {{ execute }}

`cd /opt/code-server && docker compose down` {{ execute }}

### Remove Volumes (Deletes Data!)

`docker volume rm nginx-proxy-manager_npm-data` {{ execute }}

`docker volume rm nginx-proxy-manager_npm-letsencrypt` {{ execute }}

`docker volume rm code-server_code-server-config` {{ execute }}

`docker volume rm code-server_code-server-data` {{ execute }}

### Remove Network

`docker network rm web_network` {{ execute }}

### Delete Server

In Hetzner Cloud Console:
1. Select server
2. Click "Delete"
3. Confirm deletion

---

## Part 16: What You Accomplished

Congratulations! You successfully:

âœ… Wrote a cloud-init configuration for automated OS setup
âœ… Created server with cloud-init
âœ… Deployed multi-container application with Docker Compose
âœ… Configured reverse proxy with Nginx Proxy Manager
âœ… Secured services with Let's Encrypt SSL/TLS
âœ… Understood ACME protocol for automatic certificates
âœ… Separated infrastructure automation (cloud-init) from application deployment
âœ… Debugged and verified automated deployments
âœ… Measured time savings from automation

### Skills Mastered

1. **Infrastructure as Code** - Configuration files define infrastructure
2. **Cloud-Init** - Automated server initialization
3. **Docker Compose** - Multi-container orchestration
4. **Reverse Proxy** - Traffic routing with NPM
5. **SSL/TLS Automation** - Let's Encrypt ACME protocol
6. **Container Networking** - Docker networks for service communication
7. **Persistent Storage** - Docker volumes for data
8. **Health Checks** - Monitoring container health
9. **Security** - Firewall, fail2ban, SSL/TLS
10. **Troubleshooting** - Debugging automation issues

---

## Part 17: Next Steps and Career Application

### Apply These Skills

**In Personal Projects:**
- Deploy your own applications
- Create development environments
- Host personal websites/tools
- Build portfolio projects

**For Your Resume:**
```
- Deployed containerized applications using Docker Compose
- Automated infrastructure provisioning with cloud-init
- Configured reverse proxy with SSL/TLS using Nginx Proxy Manager
- Implemented Infrastructure as Code practices
- Managed cloud resources on Hetzner Cloud
```

**For Interviews:**
- Explain cloud-init vs application deployment separation
- Describe ACME protocol for SSL automation
- Discuss container networking and orchestration
- Demonstrate understanding of idempotent operations

### Continue Learning

**Next Tools to Explore:**
- **Terraform** - Multi-cloud infrastructure automation
- **Ansible** - Configuration management at scale
- **Kubernetes** - Container orchestration for production
- **GitHub Actions** - CI/CD pipelines
- **Prometheus + Grafana** - Monitoring and alerting

**Build On This Foundation:**
1. Add database (PostgreSQL, MySQL)
2. Deploy real applications (WordPress, Ghost, etc.)
3. Set up monitoring
4. Create staging + production environments
5. Implement backup automation
6. Add log aggregation

---

## Summary

You've completed the automated infrastructure deployment lab!

**Time Investment:**
- Learning materials: 2-3 hours
- Hands-on lab: 1-2 hours
- Total: 3-5 hours

**Time Savings Achieved:**
- Single server: 75% reduction (2.3 hours â†’ 35 minutes)
- Five servers: 90% reduction (11.7 hours â†’ 1.2 hours)

**Career Value:**
- Entry-level DevOps skills âœ…
- Cloud engineering fundamentals âœ…
- Automation best practices âœ…
- Security implementation âœ…
- Production-ready knowledge âœ…

**You're now ready for:**
- Junior DevOps Engineer roles
- Cloud Support Engineer positions
- System Administrator roles with automation focus
- Freelance infrastructure consulting

Great work! ðŸŽ‰ðŸš€

---

**Previous:** [03 - Bash Scripting Deep Dive](./03-bash-scripting-deep-dive.mdcl)
**Course Home:** [Week 3 README](./README.md)
