# Bash Scripting Deep Dive: Automating Infrastructure Deployment

## What is Bash?

**Bash** (Bourne Again Shell) is the default command-line interface (CLI) and scripting language for most Linux systems. When you SSH into a server and type commands, you're using Bash.

**Bash scripting** means writing those commands into a file so they run automatically, in sequence, without human interaction.

### Why "Bash"?

- **Bourne** = Named after Stephen Bourne, creator of the original Unix shell
- **Again** = It's a pun! Bash is an improved version "born again"
- **Shell** = The command-line interface that surrounds the operating system

### Shell vs Bash vs Terminal

**Terminal:** The application window where you type commands (e.g., Terminal.app, iTerm2, Windows Terminal)

**Shell:** The program that interprets your commands (Bash, Zsh, Fish, etc.)

**Bash:** One specific type of shell (the most common one)

```
┌─────────────────────────────────┐
│   Terminal (the window)         │
│  ┌───────────────────────────┐  │
│  │  Shell (the interpreter)  │  │
│  │  (Bash, Zsh, Fish, etc.)  │  │
│  └───────────────────────────┘  │
└─────────────────────────────────┘
```

## Why Bash for Automation?

1. **Pre-installed** - Available on virtually every Linux server
2. **Simple** - Easy to learn for basic tasks
3. **Powerful** - Can accomplish complex automation
4. **Integrated** - Direct access to all system commands
5. **Universal** - Skills transfer across all Linux distributions

## Your First Bash Script

### The Basics

Create a file called `hello.sh`:

```bash{{ execute }}
#!/bin/bash
# This is a comment - it's ignored by the computer

echo "Hello, World!"
echo "This is my first Bash script"
```

**Breaking it down:**

**#!/bin/bash** = "Shebang" line
- `#!` is called a "shebang" or "hashbang"
- `/bin/bash` is the path to the Bash interpreter
- Tells the system "use Bash to run this file"

**# Comments** = Documentation for humans
- Lines starting with `#` are comments
- Computer ignores them
- Humans read them to understand the code

**echo** = Print to screen
- `echo "text"` displays text
- Like `console.log()` in JavaScript or `print()` in Python

### Making Scripts Executable

Before you can run a script, make it executable:

`chmod +x hello.sh` {{ execute }}

`./hello.sh` {{ execute }}

**chmod** = "Change mode" (change permissions)
**+x** = Add execute permission
**./hello.sh** = Run the script in current directory

## Bash Script Structure

A well-structured bash script follows this pattern:

```bash{{ copy }}
#!/bin/bash

################################################################################
# Script Description
################################################################################
# What this script does
# How to use it
# Author, version, date, etc.

################################################################################
# CONFIGURATION VARIABLES
################################################################################
# Variables that might change
DOMAIN="example.com"
PORT=8080

################################################################################
# STRICT MODE
################################################################################
# Exit on errors, print commands
set -e  # Exit if any command fails
set -x  # Print each command before running it

################################################################################
# FUNCTIONS
################################################################################
# Reusable pieces of code
function_name() {
    # Function code here
}

################################################################################
# MAIN SCRIPT
################################################################################
# The actual work happens here
echo "Starting script..."

# Do the work
function_name

echo "Script complete!"
```

## Variables

Variables store data you want to reuse or change.

### Creating and Using Variables

```bash{{ copy }}
#!/bin/bash

# Create variables (no spaces around =!)
NAME="BroTech Labs"
PORT=80
DOMAIN="brotechlabs.com"

# Use variables with $
echo "Welcome to $NAME"
echo "Running on port $PORT"
echo "Domain: $DOMAIN"

# Variables in strings
FULL_URL="https://$DOMAIN:$PORT"
echo $FULL_URL
```

**Rules for variables:**

**1. No spaces around `=`**

```bash
# Correct
NAME="value"

# Wrong!
NAME = "value"
```

**2. Use `$` to access the value**

```bash
PORT=80
echo $PORT    # Prints: 80
echo PORT     # Prints: PORT (literal text)
```

**3. Quote strings with spaces**

```bash
MESSAGE="Hello World"  # Correct
MESSAGE=Hello World    # Wrong! Bash sees two separate things
```

**4. Variable names are case-sensitive**

```bash
name="john"
NAME="JOHN"  # Different variable!
```

### Command Output in Variables

You can store command output in variables:

```bash{{ execute }}
# Capture command output
CURRENT_DATE=$(date)
echo "Today is: $CURRENT_DATE"

# Get server IP
SERVER_IP=$(hostname -I | awk '{print $1}')
echo "Server IP: $SERVER_IP"

# Count files in directory
FILE_COUNT=$(ls | wc -l)
echo "Number of files: $FILE_COUNT"
```

**Syntax:** `VARIABLE=$(command)`

### Special Variables

Bash provides special built-in variables:

```bash{{ execute }}
#!/bin/bash

# $0 = Script name
echo "Script name: $0"

# $1, $2, $3... = Arguments passed to script
echo "First argument: $1"
echo "Second argument: $2"

# $# = Number of arguments
echo "Number of arguments: $#"

# $@ = All arguments
echo "All arguments: $@"

# $? = Exit code of last command (0 = success, non-zero = error)
ls /existing/directory
echo "Exit code: $?"  # Will be 0

ls /nonexistent/directory 2>/dev/null
echo "Exit code: $?"  # Will be non-zero (error)

# $$ = Process ID of current script
echo "My process ID: $$"

# $USER = Current username
echo "Running as: $USER"

# $HOME = User's home directory
echo "Home directory: $HOME"
```

### Example: Using Script Arguments

```bash
#!/bin/bash
# Script: deploy.sh
# Usage: ./deploy.sh domain port

DOMAIN=$1
PORT=$2

echo "Deploying to domain: $DOMAIN"
echo "Using port: $PORT"
```

Run it:

`./deploy.sh brotechlabs.com 8080` {{ execute }}

Output:
```
Deploying to domain: brotechlabs.com
Using port: 8080
```

## Control Flow

### If Statements

```bash
#!/bin/bash

# Basic if statement
if [ -f /etc/passwd ]; then
    echo "File exists"
fi

# If-else
if [ -d /opt/apps ]; then
    echo "Directory exists"
else
    echo "Directory does not exist"
    mkdir -p /opt/apps
fi

# If-elif-else
if [ "$PORT" -eq 80 ]; then
    echo "Using HTTP"
elif [ "$PORT" -eq 443 ]; then
    echo "Using HTTPS"
else
    echo "Using custom port: $PORT"
fi
```

**Syntax notes:**

- **Spaces matter!** `[` is a command, so it needs spaces:
  ```bash
  # Correct
  if [ condition ]; then

  # Wrong!
  if [condition]; then
  ```

- **Semicolon or newline before `then`:**
  ```bash
  # Option 1: Semicolon
  if [ condition ]; then

  # Option 2: Newline
  if [ condition ]
  then
  ```

### Common Test Conditions

File tests:

```bash
# File exists
if [ -f /path/to/file ]; then

# Directory exists
if [ -d /path/to/directory ]; then

# File is executable
if [ -x /path/to/script ]; then

# File is readable
if [ -r /path/to/file ]; then
```

**String comparisons:**
```bash
# Strings are equal
if [ "$VAR" = "value" ]; then

# Strings are not equal
if [ "$VAR" != "value" ]; then

# String is empty
if [ -z "$VAR" ]; then

# String is not empty
if [ -n "$VAR" ]; then
```

**Number comparisons:**
```bash
# Equal
if [ "$NUM" -eq 10 ]; then

# Not equal
if [ "$NUM" -ne 10 ]; then

# Greater than
if [ "$NUM" -gt 10 ]; then

# Greater than or equal
if [ "$NUM" -ge 10 ]; then

# Less than
if [ "$NUM" -lt 10 ]; then

# Less than or equal
if [ "$NUM" -le 10 ]; then
```

**Combining conditions:**
```bash
# AND: both conditions must be true
if [ -f /etc/passwd ] && [ -d /opt/apps ]; then
    echo "Both exist"
fi

# OR: at least one condition must be true
if [ "$PORT" -eq 80 ] || [ "$PORT" -eq 443 ]; then
    echo "Standard web port"
fi

# NOT: invert condition
if [ ! -d /opt/apps ]; then
    echo "Directory does not exist"
    mkdir -p /opt/apps
fi
```

### Loops

**For loop:**

```bash
# Loop through list
for item in apple banana cherry; do
    echo "Fruit: $item"
done

# Loop through numbers
for i in {1..5}; do
    echo "Number: $i"
done

# Loop through files
for file in /opt/apps/*; do
    echo "Found file: $file"
done

# Loop through array
SERVERS=("web1" "web2" "web3")
for server in "${SERVERS[@]}"; do
    echo "Server: $server"
done
```

**While loop:**
```bash
# Loop while condition is true
COUNT=1
while [ $COUNT -le 5 ]; do
    echo "Count: $COUNT"
    COUNT=$((COUNT + 1))
done

# Loop until command succeeds
while ! curl -s http://localhost:8080 > /dev/null; do
    echo "Waiting for service..."
    sleep 5
done
echo "Service is up!"
```

## Functions

Functions are reusable blocks of code.

### Basic Function

```bash
#!/bin/bash

# Define a function
greet() {
    echo "Hello, $1!"
}

# Call the function
greet "World"
greet "BroTech Labs"
```

### Function with Return Value

```bash
#!/bin/bash

# Function that returns exit code
check_docker() {
    if command -v docker &> /dev/null; then
        return 0  # Success
    else
        return 1  # Failure
    fi
}

# Use the function
if check_docker; then
    echo "Docker is installed"
else
    echo "Docker is not installed"
fi
```

### Function Best Practices

```bash
#!/bin/bash

# Use descriptive names
# Add comments
# Use local variables

# Print informational message
# Usage: print_info "message"
print_info() {
    local message=$1
    echo -e "[INFO] $message"
}

# Print error message
# Usage: print_error "message"
print_error() {
    local message=$1
    echo -e "[ERROR] $message" >&2  # Print to stderr
}

# Check if command exists
# Usage: command_exists docker
command_exists() {
    local cmd=$1
    command -v "$cmd" &> /dev/null
}

# Example usage
print_info "Starting deployment..."

if command_exists docker; then
    print_info "Docker is available"
else
    print_error "Docker is not installed!"
    exit 1
fi
```

## Error Handling

### Strict Mode

Always use strict mode for automation scripts:

```bash
#!/bin/bash

# Exit immediately if command fails
set -e

# Print commands before executing (helpful for debugging)
set -x

# Fail on undefined variables
set -u

# Pipelines fail if any command fails (not just the last one)
set -o pipefail

# Shorter version: combine all flags
set -euxo pipefail
```

**What each flag does:**

**`set -e`** - Exit on error
```bash
#!/bin/bash
set -e

ls /existing/directory  # Success
echo "This runs"

ls /nonexistent/directory  # Fails - script exits here!
echo "This never runs"
```

**`set -x`** - Print commands
```bash
#!/bin/bash
set -x

NAME="BroTech"
echo "Hello, $NAME"

# Output:
# + NAME=BroTech
# + echo 'Hello, BroTech'
# Hello, BroTech
```

**`set -u`** - Error on undefined variables
```bash
#!/bin/bash
set -u

echo $UNDEFINED_VAR  # Error! Variable not set
```

**`set -o pipefail`** - Fail on pipeline errors
```bash
#!/bin/bash
set -o pipefail

# Without pipefail: exits with 0 (success) because grep succeeds
cat nonexistent.txt | grep "pattern"

# With pipefail: exits with error because cat fails
```

### Checking Command Success

```bash
#!/bin/bash

# Method 1: Check exit code
docker ps
if [ $? -eq 0 ]; then
    echo "Docker is running"
else
    echo "Docker is not running"
fi

# Method 2: Use command directly in if
if docker ps &> /dev/null; then
    echo "Docker is running"
else
    echo "Docker is not running"
fi

# Method 3: Run command or show error
docker ps || {
    echo "Error: Docker is not running!"
    exit 1
}
```

### Try-Catch Pattern

Bash doesn't have try-catch, but you can simulate it:

```bash
#!/bin/bash

# Temporarily disable exit on error
set +e

# Try running command
docker pull nginx:latest
EXIT_CODE=$?

# Re-enable exit on error
set -e

# Check if command succeeded
if [ $EXIT_CODE -eq 0 ]; then
    echo "Successfully pulled image"
else
    echo "Failed to pull image"
    echo "Trying alternative..."
    docker pull nginx:alpine
fi
```

## Advanced Patterns for Infrastructure Automation

### Pattern 1: Colored Output

Make your scripts easier to read with colors:

```bash
#!/bin/bash

# Color codes
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'  # No Color

# Print functions
print_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

print_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

print_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Usage
print_info "Starting deployment..."
print_success "Deployment complete!"
print_warning "Low disk space"
print_error "Failed to connect to database"
```

### Pattern 2: Waiting for Services

```bash
#!/bin/bash

# Wait for service to be ready
# Usage: wait_for_service "Service Name" "http://localhost:8080"
wait_for_service() {
    local service_name=$1
    local url=$2
    local max_attempts=30
    local attempt=1

    print_info "Waiting for $service_name to be ready..."

    while [ $attempt -le $max_attempts ]; do
        # Check if service responds
        if curl -s -o /dev/null -w "%{http_code}" "$url" | grep -q "200\|302\|401"; then
            print_success "$service_name is ready!"
            return 0
        fi

        print_info "Attempt $attempt/$max_attempts - waiting..."
        sleep 5
        ((attempt++))
    done

    print_error "$service_name failed to start"
    return 1
}

# Usage
wait_for_service "Nginx Proxy Manager" "http://localhost:81"
wait_for_service "Code-Server" "http://localhost:8080"
```

### Pattern 3: Configuration Validation

```bash
#!/bin/bash

# Validate required variables
validate_config() {
    local errors=0

    # Check if variables are set
    if [ -z "$DOMAIN" ]; then
        print_error "DOMAIN is not set"
        errors=$((errors + 1))
    fi

    if [ -z "$EMAIL" ]; then
        print_error "EMAIL is not set"
        errors=$((errors + 1))
    fi

    # Check if domain is valid format
    if ! echo "$DOMAIN" | grep -qE '^[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'; then
        print_error "DOMAIN format is invalid: $DOMAIN"
        errors=$((errors + 1))
    fi

    # Return error if any validation failed
    if [ $errors -gt 0 ]; then
        print_error "Configuration validation failed with $errors error(s)"
        return 1
    fi

    print_success "Configuration validation passed"
    return 0
}

# Configuration
DOMAIN="brotechlabs.com"
EMAIL="admin@brotechlabs.com"

# Validate before proceeding
if ! validate_config; then
    exit 1
fi
```

### Pattern 4: Idempotent Operations

Make scripts safe to run multiple times:

```bash
#!/bin/bash

# Create directory only if it doesn't exist
create_directory() {
    local dir=$1

    if [ -d "$dir" ]; then
        print_warning "Directory already exists: $dir"
    else
        print_info "Creating directory: $dir"
        mkdir -p "$dir"
        print_success "Created: $dir"
    fi
}

# Create Docker network only if it doesn't exist
create_network() {
    local network=$1

    if docker network ls | grep -q "$network"; then
        print_warning "Network already exists: $network"
    else
        print_info "Creating Docker network: $network"
        docker network create "$network"
        print_success "Network created: $network"
    fi
}

# Start container only if not running
start_container() {
    local container=$1

    if docker ps --format '{{.Names}}' | grep -q "^$container$"; then
        print_warning "Container already running: $container"
    else
        print_info "Starting container: $container"
        docker start "$container" || docker-compose up -d
        print_success "Container started: $container"
    fi
}
```

### Pattern 5: Creating Configuration Files

Use heredocs to create files:

```bash
#!/bin/bash

DOMAIN="brotechlabs.com"
PORT=8080

# Create config file with variable substitution
cat > /opt/app/config.json << EOF
{
  "domain": "${DOMAIN}",
  "port": ${PORT},
  "ssl": true
}
EOF

# Create script without variable substitution (use 'EOF' in quotes)
cat > /opt/app/script.sh << 'EOF'
#!/bin/bash
# Variables like $PATH won't be substituted
echo "PATH is: $PATH"
EOF

# Make script executable
chmod +x /opt/app/script.sh
```

### Pattern 6: Section Headers

Organize long scripts with clear sections:

```bash
#!/bin/bash

print_section() {
    local title=$1
    echo ""
    echo "========================================"
    echo "  $title"
    echo "========================================"
    echo ""
}

# Use it
print_section "Installing Dependencies"
apt update
apt install -y docker.io

print_section "Configuring Firewall"
ufw allow 80/tcp
ufw allow 443/tcp

print_section "Deployment Complete"
echo "System is ready!"
```

## Real-World Example: Docker Deployment Script

Here's a complete, production-ready deployment script:

```bash
#!/bin/bash

################################################################################
# Application Deployment Script
################################################################################
# Deploys Nginx Proxy Manager and Code-Server with Docker Compose
#
# Usage: sudo bash deploy.sh
# Author: BroTech Labs
# Version: 1.0
################################################################################

# Strict mode
set -e
set -x

################################################################################
# CONFIGURATION
################################################################################

DOMAIN="brotechlabs.com"
NPM_SUBDOMAIN="npm"
CODE_SUBDOMAIN="code"
CODE_PASSWORD="changeme123"

NPM_DIR="/opt/nginx-proxy-manager"
CODE_DIR="/opt/code-server"
NETWORK_NAME="web_network"

################################################################################
# COLORS
################################################################################

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

################################################################################
# HELPER FUNCTIONS
################################################################################

print_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

print_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

print_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

print_section() {
    echo ""
    echo -e "${BLUE}========================================${NC}"
    echo -e "${BLUE}  $1${NC}"
    echo -e "${BLUE}========================================${NC}"
    echo ""
}

command_exists() {
    command -v "$1" &> /dev/null
}

wait_for_service() {
    local service_name=$1
    local url=$2
    local max_attempts=30
    local attempt=1

    print_info "Waiting for $service_name..."

    while [ $attempt -le $max_attempts ]; do
        if curl -s -o /dev/null -w "%{http_code}" "$url" | grep -q "200\|302\|401"; then
            print_success "$service_name is ready!"
            return 0
        fi

        sleep 5
        ((attempt++))
    done

    print_error "$service_name failed to start"
    return 1
}

################################################################################
# PREREQUISITE CHECKS
################################################################################

print_section "Checking Prerequisites"

# Check if root
if [ "$EUID" -ne 0 ]; then
    print_error "This script must be run as root"
    exit 1
fi

print_success "Running as root"

# Check if Docker is installed
if ! command_exists docker; then
    print_error "Docker is not installed!"
    exit 1
fi

print_success "Docker is installed"

# Check if Docker is running
if ! docker info &> /dev/null; then
    print_info "Starting Docker..."
    systemctl start docker
fi

print_success "Docker is running"

################################################################################
# NETWORK SETUP
################################################################################

print_section "Setting Up Network"

if docker network ls | grep -q "$NETWORK_NAME"; then
    print_warning "Network already exists: $NETWORK_NAME"
else
    print_info "Creating network: $NETWORK_NAME"
    docker network create "$NETWORK_NAME"
    print_success "Network created"
fi

################################################################################
# DEPLOY NGINX PROXY MANAGER
################################################################################

print_section "Deploying Nginx Proxy Manager"

mkdir -p "$NPM_DIR"

cat > "$NPM_DIR/docker-compose.yml" << 'EOF'
version: '3.8'
services:
  nginx-proxy-manager:
    image: jc21/nginx-proxy-manager:latest
    container_name: nginx-proxy-manager
    restart: unless-stopped
    ports:
      - "80:80"
      - "443:443"
      - "81:81"
    volumes:
      - npm-data:/data
      - npm-letsencrypt:/etc/letsencrypt
    networks:
      - web_network

volumes:
  npm-data:
  npm-letsencrypt:

networks:
  web_network:
    external: true
EOF

cd "$NPM_DIR"
docker compose up -d

wait_for_service "Nginx Proxy Manager" "http://localhost:81"

################################################################################
# DEPLOY CODE-SERVER
################################################################################

print_section "Deploying Code-Server"

mkdir -p "$CODE_DIR"

cat > "$CODE_DIR/docker-compose.yml" << EOF
version: '3.8'
services:
  code-server:
    image: codercom/code-server:latest
    container_name: code-server
    restart: unless-stopped
    environment:
      PASSWORD: ${CODE_PASSWORD}
    volumes:
      - code-data:/home/coder/project
    networks:
      - web_network

volumes:
  code-data:

networks:
  web_network:
    external: true
EOF

cd "$CODE_DIR"
docker compose up -d

wait_for_service "Code-Server" "http://localhost:8080"

################################################################################
# FINAL MESSAGE
################################################################################

print_section "Deployment Complete!"

SERVER_IP=$(hostname -I | awk '{print $1}')

cat << EOF

${GREEN}Infrastructure deployed successfully!${NC}

${BLUE}Nginx Proxy Manager:${NC}
  URL: http://${SERVER_IP}:81
  Default Login:
    Email: admin@example.com
    Password: changeme

${BLUE}Code-Server:${NC}
  Internal URL: http://${SERVER_IP}:8080
  Password: ${CODE_PASSWORD}

${BLUE}Next Steps:${NC}
1. Configure DNS for ${NPM_SUBDOMAIN}.${DOMAIN}
2. Configure DNS for ${CODE_SUBDOMAIN}.${DOMAIN}
3. Set up proxy hosts in NPM
4. Enable SSL with Let's Encrypt

EOF
```

## Debugging Bash Scripts

### Common Errors

**Error: "command not found"**
```bash
# Symptom
./script.sh: line 10: docker: command not found

# Causes
1. Command not installed
2. Command not in $PATH
3. Typo in command name

# Fix
which docker          # Check if installed
echo $PATH            # Check PATH
apt install docker.io # Install if needed
```

**Error: "Permission denied"**
```bash
# Symptom
bash: ./script.sh: Permission denied

# Fix
chmod +x script.sh
```

**Error: "No such file or directory"**
```bash
# Symptom
./script.sh: line 15: /opt/app/config.json: No such file or directory

# Causes
1. Directory doesn't exist
2. Typo in path

# Fix
mkdir -p /opt/app    # Create directory first
ls -la /opt/app      # Verify path
```

**Error: "unexpected token"**
```bash
# Symptom
./script.sh: line 10: syntax error near unexpected token `fi'

# Causes
1. Missing `then` in if statement
2. Missing `do` in loop
3. Missing closing quote

# Fix
# Wrong
if [ condition ]
    echo "test"
fi

# Correct
if [ condition ]; then
    echo "test"
fi
```

### Debugging Techniques

**1. Use `set -x` to trace execution:**
```bash
#!/bin/bash
set -x  # Enable tracing

echo "This will show the command before running"
```

**2. Add echo statements:**
```bash
#!/bin/bash

echo "DEBUG: Starting deployment"
docker compose up -d
echo "DEBUG: Deployment command executed"
```

**3. Check variable values:**
```bash
#!/bin/bash

DOMAIN="brotechlabs.com"
echo "DEBUG: DOMAIN = $DOMAIN"

# Or use bash -x
bash -x script.sh
```

**4. Run commands manually:**
```bash
# Instead of running full script, copy commands one by one
# and run them manually to see where it fails
```

## Best Practices Summary

**1. Always use strict mode:**

```bash
set -euxo pipefail
```

**2. Use functions for reusability:**

```bash
print_info() {
    echo "[INFO] $1"
}
```

**3. Validate inputs:**

```bash
if [ -z "$REQUIRED_VAR" ]; then
    echo "ERROR: REQUIRED_VAR is not set"
    exit 1
fi
```

**4. Make operations idempotent:**

```bash
docker network create web_network || true
```

**5. Use meaningful variable names:**

```bash
# Good
DATABASE_HOST="db.example.com"

# Bad
H="db.example.com"
```

**6. Add comments generously:**

```bash
# Create Docker network for container communication
docker network create web_network
```

**7. Check command success:**

```bash
if ! docker ps; then
    echo "Docker is not running"
    exit 1
fi
```

**8. Quote variables:**

```bash
# Good
if [ -d "$DIRECTORY" ]; then

# Bad (fails if DIRECTORY has spaces)
if [ -d $DIRECTORY ]; then
```

## Practice Exercises

### Exercise 1: Basic Script

Write a script that:
1. Prints "Starting deployment"
2. Creates directory `/opt/myapp`
3. Prints "Deployment complete"

<details>
<summary>Solution</summary>

```bash{{ copy }}
#!/bin/bash
set -e

echo "Starting deployment"
mkdir -p /opt/myapp
echo "Deployment complete"
```

Save as `exercise1.sh`, make executable, and run:

`chmod +x exercise1.sh` {{ execute }}

`./exercise1.sh` {{ execute }}

</details>

### Exercise 2: Using Functions

Write a script with a function `create_dir()` that:
1. Takes directory path as argument
2. Checks if directory exists
3. Creates it if it doesn't
4. Prints appropriate message

<details>
<summary>Solution</summary>

```bash{{ copy }}
#!/bin/bash
set -e

create_dir() {
    local dir=$1

    if [ -d "$dir" ]; then
        echo "Directory already exists: $dir"
    else
        echo "Creating directory: $dir"
        mkdir -p "$dir"
        echo "Created: $dir"
    fi
}

# Use the function
create_dir "/opt/app1"
create_dir "/opt/app2"
create_dir "/opt/app3"
```

Save as `exercise2.sh`, make executable, and run:

`chmod +x exercise2.sh` {{ execute }}

`./exercise2.sh` {{ execute }}

</details>

### Exercise 3: Service Health Check

Write a function that:
1. Takes service name and port as arguments
2. Checks if service responds on that port
3. Waits up to 60 seconds
4. Returns success or failure

<details>
<summary>Solution</summary>

```bash{{ copy }}
#!/bin/bash
set -e

wait_for_service() {
    local service=$1
    local port=$2
    local attempts=12  # 12 attempts * 5 seconds = 60 seconds
    local count=1

    echo "Waiting for $service on port $port..."

    while [ $count -le $attempts ]; do
        if nc -z localhost $port &> /dev/null; then
            echo "$service is ready!"
            return 0
        fi

        echo "Attempt $count/$attempts..."
        sleep 5
        ((count++))
    done

    echo "ERROR: $service failed to start"
    return 1
}

# Usage
wait_for_service "Nginx" 80
wait_for_service "Code-Server" 8080
```

Save as `exercise3.sh`, make executable, and run:

`chmod +x exercise3.sh` {{ execute }}

`./exercise3.sh` {{ execute }}

</details>

## Summary

You've learned bash scripting fundamentals for infrastructure automation:

✅ Basic syntax and structure
✅ Variables and special variables
✅ Control flow (if, loops)
✅ Functions
✅ Error handling and strict mode
✅ Advanced automation patterns
✅ Debugging techniques
✅ Best practices

**Key Takeaways:**

1. **Use `set -e` and `set -x`** for safer scripts
2. **Functions make code reusable** and organized
3. **Check prerequisites** before running operations
4. **Validate inputs** to catch errors early
5. **Make operations idempotent** for safety
6. **Add color and formatting** for better UX
7. **Wait for services** before proceeding
8. **Log everything important** for debugging

**What's Next:**

Now that you understand both cloud-init and bash scripting, let's put it all together in a hands-on automated deployment lab!

---

**Next:** [04 - Automated Deployment Lab](./04-automated-deployment.mdcl)
